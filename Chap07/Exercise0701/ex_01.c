/*
	예제 7-1 : 배열의 바이트 크기와 크기 구하기
*/
 
#include <stdio.h>

int main()
{
	int arr[5];
	int byte_size = 0;
	int size = 0;
	int i;

	byte_size = sizeof(arr); 
	printf("배열의 바이트 크기 : %d\n", byte_size);
	/*
		이 경우에는 배열의 이름 첫 번째 주소 x 
		- > 배열의 전체를 가리킴 
		1. const int 변수처럼 보기의 관점에서는 컴파일러는 이미 그 크기와 
			형태를 모두 알고 있으므로 전체 반환
		2. 배열의 이름을 자동 변환 decay의 관점에서는 붕괴가 일어나지 않는
			연산의 경우임.
		중요한 건 배열을 포인터처럼 포인터를 배열처럼 활용 할수 있다는 것이 중요
		a[i] == *(a + i) 는 완전히 동치 
	*/
	size = sizeof(arr) / sizeof(arr[0]);
	printf("배열의 크기: %d\n", size);
	/*
		배열의 크기(원소의 개수)를 구하는 방식이다. 
		배열의 전체 크기가 (한 원소의 데이터 타입 크기) x 갯수 이기에 원소의 데이터 타입 크기로
		나누게 된다면 갯수만 남는다. 갯수는 보통 많은 량의 데이터의 나열인 배열의 특성상 for 문과
		많이 사용하게 되는데 for문의 반복 횟수로써 많이 이용된다. 기본적으로 함수의 매개인자로
		배열을 넘겨주면 컴파일러는 그 크기를 모르기 때문에 이 크기 변수도 함계 넘겨 준다.

		그럼 왜 a[0] 인가? 인덱스가 0인 이유는 배열의 크기가 최소 1칸 즉 인덱스로 0이기 때문이다.
		1칸 이상일 수도 있지만 아닌경우 잘못된 접근으로 컴파일러가 오류를 내기 때문에 a[1],a[n] 이 
		아닌 a[0]가 들어가게 된다.

		최대 최소를 구할 때도 비슷한 양상이 있다. 배열안에 숫자가 쭉 있고 최댓값을 찾아야 한다고 하자.
		기본적으로 배열을 순회하며 최대값을 찾기 위해 최댓값을 저장하는 변수를 선언하는데 이때 0,이나
		다른 숫자가 아닌 a[0]로 초기화 한다. 그 이유는 위와 비슷하게 배열 안에 값이 어떻게 구성되어
		있는지 모르기 때문이다.

	*/
	
	for (i = 0; i < size; i++)
		arr[i] = 0;
	
	return 0;
}
